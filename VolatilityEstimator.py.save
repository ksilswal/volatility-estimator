import numpy as np
import pandas as pd
from __future__ import annotations

TRADING_DAYS = 252

def _to_series(x) -> pd.Series:
    if isinstance(x, pd.Series):
        return x.dropna()
    return pd.Series(x).dropna()

def log_returns(close: pd.Series) -> pd.Series:
    close = _to_series(close)
    return np.log(close).diff().dropna()

def annualize_vol(daily_vol: Union[pd.Series, float], periods_per_year: int = TRADING_DAYS):
    return daily_vol * np.sqrt(periods_per_year)

# 1) Close-to-close (rolling) historical volatility
def close_to_close_vol(close, window: int = 20, annualize: bool = True, periods_per_year: int = TRADING_DAYS):
    r = log_returns(_to_series(close))
    vol = r.rolling(window).std(ddof=1)
    return annualize_vol(vol, periods_per_year) if annualize else vol

# 2) EWMA volatility (RiskMetrics)
def ewma_vol(close, lam: float = 0.94, annualize: bool = True, periods_per_year: int = TRADING_DAYS):
    r = log_returns(_to_series(close))
    # EWMA variance recursion: sigma_t^2 = lam*sigma_{t-1}^2 + (1-lam)*r_t^2
    var = np.zeros(len(r))
    var[0] = r.iloc[:min(30, len(r))].var(ddof=1) if len(r) > 1 else 0.0
    for i in range(1, len(r)):
        var[i] = lam * var[i-1] + (1.0 - lam) * (r.iloc[i] ** 2)
    vol = pd.Series(np.sqrt(var), index=r.index)
    return annualize_vol(vol, periods_per_year) if annualize else vol

# Helpers for OHLC estimators
def _ohlc(df: pd.DataFrame):
    # expects columns: Open, High, Low, Close (case-insensitive ok if you rename beforehand)
    o = _to_series(df["Open"])
    h = _to_series(df["High"])
    l = _to_series(df["Low"])
    c = _to_series(df["Close"])
    # align
    common = o.index.intersection(h.index).intersection(l.index).intersection(c.index)
    return o.loc[common], h.loc[common], l.loc[common], c.loc[common]

# 3) Parkinson (high-low) daily variance, rolling mean
def parkinson_vol(df_ohlc: pd.DataFrame, window: int = 20, annualize: bool = True, periods_per_year: int = TRADING_DAYS):
    o, h, l, c = _ohlc(df_ohlc)
    rs = (np.log(h / l) ** 2) / (4.0 * np.log(2.0))
    var = rs.rolling(window).mean()
    vol = np.sqrt(var)
    return annualize_vol(vol, periods_per_year) if annualize else vol

# 4) Garman–Klass (OHLC) daily variance, rolling mean
def garman_klass_vol(df_ohlc: pd.DataFrame, window: int = 20, annualize: bool = True, periods_per_year: int = TRADING_DAYS):
    o, h, l, c = _ohlc(df_ohlc)
    log_hl = np.log(h / l)
    log_co = np.log(c / o)
    var_daily = 0.5 * (log_hl ** 2) - (2.0 * np.log(2.0) - 1.0) * (log_co ** 2)
    var = var_daily.rolling(window).mean()
    vol = np.sqrt(var.clip(lower=0.0))
    return annualize_vol(vol, periods_per_year) if annualize else vol

# 5) Yang–Zhang (handles overnight gap; strong “project flex”)
def yang_zhang_vol(df_ohlc: pd.DataFrame, window: int = 20, annualize: bool = True, periods_per_year: int = TRADING_DAYS):
    o, h, l, c = _ohlc(df_ohlc)

    c_prev = c.shift(1)
    o_prev = o.shift(1)

    # overnight return and open-to-close return
    r_overnight = np.log(o / c_prev)
    r_oc = np.log(c / o)

    # Rogers–Satchell component
    rs = np.log(h / o) * np.log(h / c) + np.log(l / o) * np.log(l / c)

    # windowed variances
    var_overnight = r_overnight.rolling(window).var(ddof=1)
    var_oc = r_oc.rolling(window).var(ddof=1)
    var_rs = rs.rolling(window).mean()

    # k factor
    k = 0.34 / (1.34 + (window + 1) / (window - 1))
    var_yz = var_overnight + k * var_oc + (1 - k) * var_rs

    vol = np.sqrt(var_yz.clip(lower=0.0)).dropna()
    return annualize_vol(vol, periods_per_year) if annualize else vol
X
^X

/usr/bin/python3 "/Users/ksilswal/Documents/Python Projects/notebooks/Quick Projects/Volatility Estimator/VolatilityEstimator.py"
/usr/bin/python3 "/Users/ksilswal/Documents/Python Projects/notebooks/Quick Projects/Volatility Estimator/VolatilityEstimator.py"
/usr/bin/python3 "/Users/ksilswal/Documents/Python Projects/notebooks/Quick Projects/Volatility Estimator/VolatilityEstimator.py"

